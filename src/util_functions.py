"""Module for processing geospatial and yield data, plotting various metrics,and transforming shapefiles for ecosystem carbon analysis."""import osimport shutilimport pickleimport randomimport mathfrom collections import Counterimport collectionsfrom functools import partialimport numpy as npimport pandas as pdimport geopandas as gpdfrom geopandas import GeoDataFrame, GeoSeriesimport matplotlib.pyplot as pltfrom mpl_toolkits.basemap import Basemapfrom matplotlib.colors import TwoSlopeNormimport fionafrom fiona.crs import from_epsgfrom netCDF4 import Datasetimport pyprojfrom scipy.interpolate import make_interp_splineimport seaborn as snsfrom matplotlib import cmfrom shapely.geometry import Point, Polygon, shape, boxfrom shapely.ops import transform, unary_union# Local application importsfrom config import Configfrom ncload import NCLoaddef load_experiment_config(cfg) -> object:    """    Load experiment configuration from a pickle file in the experiment directory.    Parameters:        cfg: Configuration object with attribute 'exps_dir'.    Returns:        Experiment configuration object.    """    exp_input_path = os.path.join(cfg.exps_dir, "1_exp")    pkl_cfg_path = os.path.join(exp_input_path, "exp_cfg.pkl")    with open(pkl_cfg_path, "rb") as f:        exp_config = pickle.load(f)    return exp_configdef basemap_plot(plot_dir: str, var, plot_name: str, plot_title: str, lats, lons, cmap, cbar_ticks, mode: str) -> None:    """    Plot a variable on a map using Basemap and save the output as a PNG.    Parameters:        plot_dir (str): Directory to save the plot.        var: Array-like data to plot.        plot_name (str): Base name for the output file.        plot_title (str): Title for the plot.        lats: Array-like sequence of latitudes.        lons: Array-like sequence of longitudes.        cmap: Colormap to use.        cbar_ticks: Ticks for the colorbar (if any).        mode (str): Map mode; either "canada" for a Mercator view of Canada or "globe" for a cylindrical projection.    """    fig = plt.figure()    if mode == "canada":        m = Basemap(llcrnrlat=44, llcrnrlon=-148, urcrnrlat=75, urcrnrlon=-50,                    resolution='l', projection='merc', lat_0=60, lon_0=-99)    elif mode == "globe":        m = Basemap(resolution='l', projection='cyl')    else:        raise ValueError(f"Unknown mode: {mode}")    lon, lat = np.meshgrid(lons, lats)    xi, yi = m(lon, lat)    norm = TwoSlopeNorm(vcenter=0)    cs = m.pcolor(xi, yi, np.squeeze(var), cmap=cmap, norm=norm)    m.drawcoastlines()    m.drawcountries()    cbar = m.colorbar(cs, location='bottom', pad="10%")    if cbar_ticks:        cbar.set_ticks(cbar_ticks)    plt.title(plot_title)    output_path = os.path.join(plot_dir, f"{plot_name}_{mode}.png")    plt.savefig(output_path)    plt.close()def create_shp_variations(aff_shp: GeoDataFrame, inv_shp: GeoDataFrame, exps_dir: str) -> None:    """    Create and save two shapefiles: one for afforestation and one for inventory data.    Parameters:        aff_shp (GeoDataFrame): Shapefile data for afforestation.        inv_shp (GeoDataFrame): Shapefile data for inventory.        exps_dir (str): Directory to save the output shapefiles.    """    gdf_inv = GeoDataFrame(columns=["geometry", "age", "ld_spp", "soil_type", "land_class"])    gdf_aff = GeoDataFrame(columns=["geometry", "year", "ld_spp", "admin", "eco"])    row = 0    for idx in range(len(aff_shp)):        eco = aff_shp.loc[idx, "eco"]        if eco == "Southern Arctic":            continue        gdf_aff.loc[row, "geometry"] = aff_shp.loc[idx, "geometry"]        gdf_aff.loc[row, "year"] = aff_shp.loc[idx, "year"]        gdf_aff.loc[row, "ld_spp"] = aff_shp.loc[idx, "ld_spp"]        gdf_aff.loc[row, "admin"] = aff_shp.loc[idx, "admin"]        gdf_aff.loc[row, "eco"] = aff_shp.loc[idx, "eco"]        gdf_inv.loc[row, "geometry"] = inv_shp.loc[idx, "geometry"]        gdf_inv.loc[row, "age"] = inv_shp.loc[idx, "age"]        gdf_inv.loc[row, "ld_spp"] = inv_shp.loc[idx, "ld_spp"]        gdf_inv.loc[row, "soil_type"] = inv_shp.loc[idx, "soil_type"]        gdf_inv.loc[row, "land_class"] = inv_shp.loc[idx, "land_class"]        row += 1    gdf_inv.set_crs(epsg=4326, inplace=True)    outfp_inv = os.path.join(exps_dir, "inventory.shp")    gdf_inv.to_file(outfp_inv)    gdf_aff.set_crs(epsg=4326, inplace=True)    outfp_aff = os.path.join(exps_dir, "afforestation.shp")    gdf_aff.to_file(outfp_aff)def store_bbox_tiles(cfg: Config) -> None:    """    Extract bounding box information from tile shapefiles and store the results in a CSV file.    Parameters:        cfg (Config): Configuration object containing 'tiles' and 'transf_dir' attributes.    """    bounds_df = pd.DataFrame(columns=["tile", "lat_min", "lat_max", "lon_min", "lon_max"])    for tile in cfg.tiles:        try:            tile_shp_path = os.path.join(cfg.transf_dir, f"tile_{tile}.shp")            with fiona.open(tile_shp_path) as tile_shp:                bbox = tile_shp.bounds            bounds_row = pd.Series({                "tile": tile,                "lat_min": bbox[0],                "lon_min": bbox[1],                "lat_max": bbox[2],                "lon_max": bbox[3]            })            bounds_df = pd.concat([bounds_df, bounds_row.to_frame().T], ignore_index=True)        except Exception:            continue    csv_path = os.path.join(cfg.transf_dir, "bounds.csv")    bounds_df.to_csv(csv_path, index=False)def transform_shp_files(cfg: Config) -> None:    """    Transform shapefiles from EPSG:3978 to EPSG:4326 projection and save the transformed files.    Parameters:        cfg (Config): Configuration object with 'nfi_shp_dir' and 'transf_dir' attributes.    """    project = partial(        pyproj.transform,        pyproj.Proj('epsg:3978'),        pyproj.Proj('epsg:4326')    )    for tile in cfg.tiles:        print(tile)        shp_path = os.path.join(cfg.nfi_shp_dir, f"CA_2020_tile_{tile}_metrics.shp")        tile_shp = gpd.read_file(shp_path)        for idx in range(len(tile_shp)):            trans_poly = transform(project, shape(tile_shp.loc[idx, 'geometry']))            tile_shp.loc[idx, "geometry"] = trans_poly        outfp_trans = os.path.join(cfg.transf_dir, f"tile_{tile}.shp")        tile_shp.to_file(outfp_trans)def get_mean_fri(disturbances_df: pd.DataFrame, exp_fire_shp: pd.DataFrame) -> float:    """    Calculate the mean Fire Return Interval (FRI) from disturbance and experimental fire data.    Parameters:        disturbances_df (pd.DataFrame): DataFrame containing disturbance years.        exp_fire_shp (pd.DataFrame): DataFrame with experimental fire data and corresponding FRI values.    Returns:        float: The calculated mean FRI. Returns 1000 if no matching FRI is found.    """    fire_years_disturbed = list(disturbances_df["year"])    fri_list = []    year_list = []    for idx in range(len(exp_fire_shp)):        year = int(exp_fire_shp.loc[idx, "year"])        if year in fire_years_disturbed:            fri_list.append(float(exp_fire_shp.loc[idx, "fri"]))            year_list.append(year)    c_dict = collections.Counter(fri_list)    if len(fri_list) == 0:        fri_mean = 1000    else:        if len(year_list) > len(fire_years_disturbed):            rem_fri = []            rep = [it for it, c in collections.Counter(year_list).items() if c > 1]            for r_year in rep:                ids = [i for i, yr in enumerate(year_list) if yr == r_year]                r_fri = [fri_list[i] for i in ids]                r_count = sum(1 for fri in r_fri if c_dict[fri] == 1)                if r_count == len(ids):                    fri_max = max(r_fri)                    rem_fri.extend([r for r in r_fri if r == fri_max])            fri_list = [fri for fri in fri_list if fri not in rem_fri]        fri_mean = np.mean(fri_list)    return fri_meandef area_fri_1(cfg: Config, yield_dict: dict) -> None:    """    Generate plots showing Total Ecosystem Carbon (TEC) vs afforestation area and vs Fire Return Interval (FRI).    Parameters:        cfg (Config): Configuration object containing plot directory and yield percentage names.        yield_dict (dict): Dictionary containing yield and carbon pool data.    """    # Plot TEC vs Afforestation Area    area_mins = []    area_maxs = []    for y_name in cfg.yield_perc_names:        ids = np.argsort(yield_dict[y_name]["area"])        yield_dict[y_name]["area"] = [yield_dict[y_name]["area"][i] for i in ids]        area_mins.append(yield_dict[y_name]["area"][0])        area_maxs.append(yield_dict[y_name]["area"][-1])        yield_dict[y_name]["fri"] = [yield_dict[y_name]["fri"][i] for i in ids]        yield_dict[y_name]["c_pool_final"] = [yield_dict[y_name]["c_pool_final"][i] for i in ids]        yield_dict[y_name]["c_pool_years"] = [yield_dict[y_name]["c_pool_years"][i] for i in ids]    area_min = np.min(area_mins)    area_max = np.max(area_maxs)    area_new = np.linspace(area_min, area_max, 200)    new_dict = {}    for y_name in cfg.yield_perc_names:        new_dict[y_name] = {}        spl = make_interp_spline(yield_dict[y_name]["area"], yield_dict[y_name]["c_pool_final"], k=1)        new_dict[y_name]["c_pool_final"] = spl(area_new)    plt.figure()    plt.plot(area_new, new_dict[cfg.yield_perc_names[0]]["c_pool_final"], c="r",             label="+40% MAT, -40% PCP")    plt.plot(area_new, new_dict[cfg.yield_perc_names[1]]["c_pool_final"], c="b",             label="Mean MAT, PCP")    plt.plot(area_new, new_dict[cfg.yield_perc_names[2]]["c_pool_final"], c="g",             label="-40% MAT, +40% PCP")    plt.legend()    plt.xlabel("Afforestation Area (Hectares)")    plt.ylabel("Total Ecosystem Carbon (Tonnes)")    plt.title("Total Ecosystem Carbon Pool vs Afforestation Area")    plt.savefig(os.path.join(cfg.plot_dir, "tec_affarea.png"))    plt.close()    # Plot TEC vs FRI    fri_mins = []    fri_maxs = []    for y_name in cfg.yield_perc_names:        ids = np.argsort(yield_dict[y_name]["fri"])        yield_dict[y_name]["fri"] = [yield_dict[y_name]["fri"][i] for i in ids]        yield_dict[y_name]["area"] = [yield_dict[y_name]["area"][i] for i in ids]        fri_mins.append(yield_dict[y_name]["fri"][0])        fri_maxs.append(yield_dict[y_name]["fri"][-1])        yield_dict[y_name]["c_pool_final"] = [yield_dict[y_name]["c_pool_final"][i] for i in ids]        yield_dict[y_name]["c_pool_years"] = [yield_dict[y_name]["c_pool_years"][i] for i in ids]    fri_min = np.min(fri_mins)    fri_max = np.max(fri_maxs)    fri_new = np.linspace(fri_min, fri_max, 200)    new_dict = {}    for y_name in cfg.yield_perc_names:        new_dict[y_name] = {}        spl = make_interp_spline(yield_dict[y_name]["fri"], yield_dict[y_name]["c_pool_final"], k=1)        new_dict[y_name]["c_pool_final"] = spl(fri_new)    plt.figure()    plt.plot(fri_new, new_dict[cfg.yield_perc_names[0]]["c_pool_final"], c="r",             label="+40% MAT, -40% PCP")    plt.plot(fri_new, new_dict[cfg.yield_perc_names[1]]["c_pool_final"], c="b",             label="Mean MAT, PCP")    plt.plot(fri_new, new_dict[cfg.yield_perc_names[2]]["c_pool_final"], c="g",             label="-40% MAT, +40% PCP")    plt.legend()    plt.xlabel("Fire Return Interval (Years)")    plt.ylabel("Total Ecosystem Carbon (Tonnes)")    plt.title("Total Ecosystem Carbon Pool vs FRI")    plt.savefig(os.path.join(cfg.plot_dir, "tec_fri.png"))    plt.close()def plot_fri(cfg: Config, yield_dict: dict, smooth: bool = True, spread: bool = True) -> None:    """    Plot Fire Return Interval (FRI) analysis based on yield data. The function either creates a smooth line plot    with confidence intervals or a bar plot with standard deviation error bars.    Parameters:        cfg (Config): Configuration object with attributes including 'exps_dir' and 'plot_dir'.        yield_dict (dict): Dictionary containing yield data.        smooth (bool): Whether to smooth the data.        spread (bool): Whether to plot data spread as bar plot.    """    exp_config = load_experiment_config(cfg)    y_name = exp_config.yield_perc    fri_list = yield_dict[y_name]["fri"].copy()    area_list = yield_dict[y_name]["area"].copy()    c_pool_final_list = yield_dict[y_name]["c_pool_final"].copy()    ids = np.argsort(fri_list)    fri = [fri_list[i] for i in ids]    area_list_sort = [area_list[i] for i in ids]    c_pool_final_list_sort = [c_pool_final_list[i] for i in ids]    c_pool = [round(y / a, 2) for y, a in zip(c_pool_final_list_sort, area_list_sort)]    if not spread:        if smooth:            sf = 100            c_pool_smooth = np.zeros(len(fri))            c_pool_std = np.zeros(len(fri))            c_pool_std_smooth = np.zeros(len(fri))            for i in range(len(fri)):                if i < sf:                    i_min = 0                    i_max = i + sf                elif i > len(fri) - sf + 1:                    i_min = i - sf                    i_max = len(fri) - 1                else:                    i_min = i - sf                    i_max = i + sf                c_pool_smooth[i] = np.mean(c_pool[i_min:i_max])                c_pool_std[i] = 0.34 * np.abs(c_pool[i] - c_pool_smooth[i])            for i in range(len(fri)):                if i < sf:                    i_min = 0                    i_max = i + sf                elif i > len(fri) - sf + 1:                    i_min = i - sf                    i_max = len(fri) - 1                else:                    i_min = i - sf                    i_max = i + sf                c_pool_std_smooth[i] = np.mean(c_pool_std[i_min:i_max])            c_pool = c_pool_smooth            c_pool_std = c_pool_std_smooth        np.save(os.path.join(cfg.plot_dir, "cpool_final_per_area.npy"), c_pool)        np.save(os.path.join(cfg.plot_dir, "fri.npy"), fri)        np.save(os.path.join(cfg.plot_dir, "cpool_std.npy"), c_pool_std)        plt.figure()        plt.plot(fri, c_pool, c="g", label="Mean MAT, PCP")        plt.fill_between(fri, np.array(c_pool) - np.array(c_pool_std), np.array(c_pool) + np.array(c_pool_std))        plt.legend()        plt.xlabel("Fire Return Interval (Years)")        plt.ylabel("Total Ecosystem Carbon (Tonnes/Hectare)")        plt.title("Total Ecosystem Carbon Pool vs FRI")        filename = "tec_fri_sf.png" if smooth else "tec_fri.png"        plt.savefig(os.path.join(cfg.plot_dir, filename))        plt.close()    else:        df = pd.DataFrame(columns=["Fire Return Interval (Years)", "Total Ecosystem Carbon (Tonnes/Hectare)"])        for i in range(len(fri)):            df.loc[i, "Fire Return Interval (Years)"] = int(fri[i])            df.loc[i, "Total Ecosystem Carbon (Tonnes/Hectare)"] = c_pool[i]        plt.figure()        sns.barplot(data=df, x="Fire Return Interval (Years)",                    y="Total Ecosystem Carbon (Tonnes/Hectare)", errorbar="sd")        plt.savefig(os.path.join(cfg.plot_dir, "tec_fri.png"))        plt.close()def plot_histogram(cfg: Config, yield_dict: dict, var: str, xlabel: str, title_add: str) -> None:    """    Plot a histogram for a given variable from the yield data and save the plot.    Parameters:        cfg (Config): Configuration object with 'exps_dir' and 'plot_dir' attributes.        yield_dict (dict): Dictionary containing yield data.        var (str): The key for the variable to plot.        xlabel (str): Label for the x-axis.        title_add (str): Additional text for the title.    """    exp_config = load_experiment_config(cfg)    y_name = exp_config.yield_perc    var_f = [float(v) for v in yield_dict[y_name][var]]    plt.figure()    plt.hist(var_f, density=True, bins=30)    plt.xlabel(xlabel)    if var == "fire_frac":        plt.xticks(np.arange(np.min(var_f), np.max(var_f), 0.2))    plt.ylabel("Density")    # plt.title("Histogram of " + title_add)    plt.savefig(os.path.join(cfg.plot_dir, f"hist_{var}.png"))    plt.close()def combine_yield_pkls(cfg: Config) -> None:    """    Combine yield dictionaries from multiple directories and plot FRI.    Note:        The list of directories to combine is currently empty.    """    dirs = []    combined_dict = {}    for directory in dirs:        plot_dir = os.path.join(cfg.plot_dir, directory)        with open(os.path.join(plot_dir, "yield_dict.pkl"), "rb") as f:            yield_dict = pickle.load(f)        if not combined_dict:            combined_dict = yield_dict        else:            for id1, val1 in yield_dict.items():                for id2, val2 in val1.items():                    for j in range(len(val2)):                        combined_dict[id1][id2].append(val2[j])    cfg.plot_dir = os.path.join(cfg.plot_dir, "4_5_combined")    with open(os.path.join(cfg.plot_dir, "yield_dict.pkl"), "wb") as f:        pickle.dump(combined_dict, f)    plot_fri(cfg, combined_dict, smooth=False, spread=True)def plot_cpool_years(cfg: Config, yield_dict: dict, mode: str) -> None:    """    Plot the Total Ecosystem Carbon (TEC) pool over simulation years.    Depending on the mode, the function either plots TEC curves for each FRI separately    or a combined mean with standard deviation.    Parameters:        cfg (Config): Configuration object containing simulation interval and plot directory.        yield_dict (dict): Dictionary containing yield and carbon pool data.        mode (str): Plot mode; either "fri_sep" for separate plots or "combine" for a combined plot.    """    exp_config = load_experiment_config(cfg)    y_name = exp_config.yield_perc    ids = np.argsort(yield_dict[y_name]["fri"])    yield_dict[y_name]["fri"] = [yield_dict[y_name]["fri"][i] for i in ids]    yield_dict[y_name]["area"] = [yield_dict[y_name]["area"][i] for i in ids]    yield_dict[y_name]["c_pool_final"] = [yield_dict[y_name]["c_pool_final"][i] for i in ids]    yield_dict[y_name]["c_pool_years"] = [yield_dict[y_name]["c_pool_years"][i] for i in ids]    fri = yield_dict[y_name]["fri"]    c_pool_years = [np.round(y / a, 2) for y, a in zip(yield_dict[y_name]["c_pool_years"],                                                        yield_dict[y_name]["area"])]    if mode == "fri_sep":        fri_cpool = {}        for i in range(len(fri)):            fri_cpool.setdefault(fri[i], []).append(c_pool_years[i])        plt.figure()        color_list = ["g", "b", "r", "y", "m", "c", "k", "pink", "violet", "brown"]        years = np.arange(cfg.sim_interval[0], cfg.sim_interval[1] + 1, 1)        for i, (fri_val, c_pool_vals) in enumerate(fri_cpool.items()):            c_pool_mean = np.mean(np.array(c_pool_vals), axis=0)            plt.plot(years, c_pool_mean, c=color_list[i], label="FRI=" + str(int(fri_val)))        plt.legend()        plt.xlabel("Years")        plt.ylabel("Total Ecosystem Carbon (Tonnes/Hectare)")        plt.title("Total Ecosystem Carbon Pool over Simulation Period")        plt.savefig(os.path.join(cfg.plot_dir, "tec_fri_years.png"))        plt.close()    elif mode == "combine":        c_pool = np.mean(np.array(c_pool_years), axis=0)        c_pool_std = np.std(np.array(c_pool_years), axis=0)        np.save(os.path.join(cfg.plot_dir, "tec_fri_years.npy"), c_pool)        np.save(os.path.join(cfg.plot_dir, "tec_fri_std_years.npy"), c_pool_std)        plt.figure()        years = np.arange(cfg.sim_interval[0], cfg.sim_interval[1] + 1, 1)        plt.plot(years, c_pool, c="g")        plt.fill_between(years, c_pool - c_pool_std, c_pool + c_pool_std)        plt.xlabel("Years")        plt.ylabel("Total Ecosystem Carbon (Tonnes/Hectare)")        plt.title("Total Ecosystem Carbon Pool over Simulation Period")        plt.savefig(os.path.join(cfg.plot_dir, "tec_fri_years.png"))        plt.close()def plot_admin_eco_perhc(cfg: Config, yield_dict: dict) -> None:    """    Plot Total Ecosystem Carbon per Hectare by Administrative and Ecological regions and save as CSV and PNG.    Parameters:        cfg (Config): Configuration object containing 'exps_dir' and 'plot_dir'.        yield_dict (dict): Dictionary containing yield data.    """    exp_config = load_experiment_config(cfg)    y_name = exp_config.yield_perc    admin = yield_dict[y_name]["admin"]    eco = yield_dict[y_name]["eco"]    c_pool = [round(y / a, 2) for y, a in zip(yield_dict[y_name]["c_pool_final"], yield_dict[y_name]["area"])]    map_dict = {        "Taiga Shield West": "TSW",        "Taiga Plains": "TP",        "Manitoba": "MB",        "Saskatchewan": "SK",        "Northwest Territories": "NT",        "Yukon": "YT"    }    df = pd.DataFrame(columns=["Admin-Eco", "Total Ecosystem Carbon (Tonnes/Hectare)"])    for i in range(len(admin)):        admin_eco = f"{map_dict[admin[i]]}-{map_dict[eco[i]]}"        df.loc[i, "Admin-Eco"] = admin_eco        df.loc[i, "Total Ecosystem Carbon (Tonnes/Hectare)"] = c_pool[i]    df.to_csv(os.path.join(cfg.plot_dir, "tec_admin_eco_perhc.csv"), index=False)    plt.figure()    sns.barplot(data=df, x="Admin-Eco", y="Total Ecosystem Carbon (Tonnes/Hectare)", errorbar="sd")    plt.title("Total Ecosystem Carbon Pool in Admin-Eco")    plt.savefig(os.path.join(cfg.plot_dir, "tec_admin_eco_perhc.png"))    plt.close()def plot_admin_eco_total(cfg: Config, yield_dict: dict) -> None:    """    Plot Total Ecosystem Carbon (in Giga Tonnes) by Administrative and Ecological regions.    Parameters:        cfg (Config): Configuration object containing 'exps_dir', 'plot_dir', and 'exp_name'.        yield_dict (dict): Dictionary containing yield data.    """    exp_config = load_experiment_config(cfg)    y_name = exp_config.yield_perc    admin = yield_dict[y_name]["admin"]    eco = yield_dict[y_name]["eco"]    free = yield_dict[y_name]["perc_free"]    perc_forest = yield_dict[y_name]["perc_forest"]    c_pool = [round(y / a, 2) for y, a in zip(yield_dict[y_name]["c_pool_final"], yield_dict[y_name]["area"])]    map_dict = {        "Taiga Shield West": "TSW",        "Taiga Plains": "MNT",  # Note: mapping as provided in original code        "Manitoba": "MNT",        "Saskatchewan": "SSKW",        "Northwest Territories": "NWT",        "Yukon": "YKN"    }    free_dict = {}    if "_bl_" in cfg.exp_name:        for i, forest_i in enumerate(perc_forest):            admin_eco = f"{map_dict[admin[i]]}-{map_dict[eco[i]]}"            free_dict[admin_eco] = free_dict.get(admin_eco, 0) + float(forest_i) / 100    else:        for i, free_i in enumerate(free):            admin_eco = f"{map_dict[admin[i]]}-{map_dict[eco[i]]}"            free_dict[admin_eco] = free_dict.get(admin_eco, 0) + float(free_i)    df = pd.DataFrame(columns=["Admin-Eco", "Total Ecosystem Carbon (Giga Tonnes)"])    for i in range(len(admin)):        admin_eco = f"{map_dict[admin[i]]}-{map_dict[eco[i]]}"        df.loc[i, "Admin-Eco"] = admin_eco        df.loc[i, "Total Ecosystem Carbon (Giga Tonnes)"] = c_pool[i] * (free_dict[admin_eco] * 10.5 * 500 * 1e-9)    df.to_csv(os.path.join(cfg.plot_dir, "tec_admin_eco.csv"), index=False)    plt.figure()    sns.barplot(data=df, x="Admin-Eco", y="Total Ecosystem Carbon (Giga Tonnes)", errorbar="sd")    plt.title("Total Ecosystem Carbon Pool in Admin-Eco")    plt.savefig(os.path.join(cfg.plot_dir, "tec_admin_eco.png"))    plt.close()def plot_fri_area_tec_line(cfg: Config, yield_dict: dict, mode: str, smooth: bool, type: str) -> None:    """    Plot Total Ecosystem Carbon (TEC) as a function of afforestation area, either separated by FRI or combined.    Parameters:        cfg (Config): Configuration object with attributes such as 'exps_dir', 'plot_dir', and 'fire_return_interval'.        yield_dict (dict): Dictionary containing yield data.        mode (str): Mode to compute or load heatmap data ("compute" or "load") when type is "fri_sep".        smooth (bool): Whether to apply smoothing to the data.        type (str): Plot type; either "fri_sep" for FRI-separated plots or "combine" for combined data.    """    exp_config = load_experiment_config(cfg)    y_name = exp_config.yield_perc    if type == "fri_sep":        if mode == "compute":            df = pd.DataFrame(columns=["fri", "area", "tec"])            row = 0            for fri in cfg.fire_return_interval:                area_list = []                tec_list = []                for fy, fri_yield in enumerate(yield_dict[y_name]["fri"]):                    if fri_yield == fri:                        area_list.append(yield_dict[y_name]["area"][fy])                        tec_list.append(yield_dict[y_name]["c_pool_final"][fy])                for n in range(1, 11):                    if n == 1:                        for i in range(len(area_list)):                            df.loc[row, "fri"] = fri                            df.loc[row, "area"] = area_list[i]                            df.loc[row, "tec"] = tec_list[i]                            row += 1                    else:                        id_pairs = np.random.choice(len(area_list), (len(area_list), n))                        for indices in id_pairs:                            area_temp = [area_list[exp_id] for exp_id in indices]                            tec_temp = [tec_list[exp_id] for exp_id in indices]                            df.loc[row, "fri"] = fri                            df.loc[row, "area"] = np.sum(area_temp)                            df.loc[row, "tec"] = np.sum(tec_temp)                            row += 1            df.to_csv(os.path.join(cfg.plot_dir, "heatmap_df.csv"), index=False)        elif mode == "load":            df = pd.read_csv(os.path.join(cfg.plot_dir, "heatmap_df.csv"))        plt.figure()        color_list = ["g", "b", "r", "y", "m", "c", "k", "pink", "violet", "brown"]        for i, fri in enumerate(cfg.fire_return_interval):            subset_df = df[df["fri"] == fri].reset_index(drop=True)            area_list = []            tec_list = []            for area in subset_df["area"].unique():                tec_mean = subset_df.loc[subset_df["area"] == area, "tec"].mean()                area_list.append(area)                tec_list.append(tec_mean)            ids = np.argsort(area_list)            area_list = [area_list[i] for i in ids]            tec_list = [tec_list[i] for i in ids]            if smooth:                tec_smooth = np.zeros(len(area_list))                sf = 150                for s in range(len(area_list)):                    if s < sf:                        i_min = 0                        i_max = s + sf                    elif s > len(area_list) - sf + 1:                        i_min = s - sf                        i_max = len(area_list) - 1                    else:                        i_min = s - sf                        i_max = s + sf                    tec_smooth[s] = np.mean(tec_list[i_min:i_max])                tec_list = list(tec_smooth)            plt.plot(area_list, tec_list, c=color_list[i], label="FRI=" + str(int(fri)))        plt.legend()        plt.xlabel("Area (Hectares)")        plt.ylabel("Total Ecosystem Carbon (Tonnes)")        plt.savefig(os.path.join(cfg.plot_dir, "tec_fri_area.png"))        plt.close()    elif type == "combine":        area_list_init = yield_dict[y_name]["area"]        tec_list_init = yield_dict[y_name]["c_pool_final"]        area_list_full = []        tec_list_full = []        for n in range(2, 11):            if n == 1:                area_list_full = area_list_init                tec_list_full = tec_list_init            else:                id_pairs = np.random.choice(len(area_list_init), (len(area_list_init), n))                for indices in id_pairs:                    area_temp = [area_list_init[exp_id] for exp_id in indices]                    tec_temp = [tec_list_init[exp_id] for exp_id in indices]                    area_list_full.append(np.sum(area_temp))                    tec_list_full.append(np.sum(tec_temp))        ids = np.argsort(area_list_full)        area_list = [area_list_full[i] for i in ids]        tec_list = [tec_list_full[i] for i in ids]        if smooth:            tec_smooth = np.zeros(len(area_list))            tec_std = np.zeros(len(area_list))            sf = 350            for s in range(len(area_list)):                if s < sf:                    i_min = 0                    i_max = s + sf                elif s > len(area_list) - sf + 1:                    i_min = s - sf                    i_max = len(area_list) - 1                else:                    i_min = s - sf                    i_max = s + sf                tec_smooth[s] = np.mean(tec_list[i_min:i_max])                tec_std[s] = np.std(tec_list[i_min:i_max])            np.save(os.path.join(cfg.plot_dir, "tec_area.npy"), tec_smooth)            np.save(os.path.join(cfg.plot_dir, "tec_area_std.npy"), tec_std)            np.save(os.path.join(cfg.plot_dir, "area_list.npy"), area_list)            plt.figure()            plt.plot(area_list, tec_smooth, c="g")            plt.fill_between(area_list, tec_smooth - tec_std, tec_smooth + tec_std, alpha=0.5)            plt.xlabel("Area (Hectares)")            plt.ylabel("Total Ecosystem Carbon (Tonnes)")            plt.title("TEC Pool over Afforestation Area")            plt.savefig(os.path.join(cfg.plot_dir, "tec_area.png"))            plt.close()def plot_tec_fri_area_heatmap(cfg: Config) -> None:    """    Create and display a heatmap of Total Ecosystem Carbon (TEC) as a function of FRI and area.    Parameters:        cfg (Config): Configuration object with 'plot_dir' attribute.    """    df = pd.read_csv(os.path.join(cfg.plot_dir, "heatmap_df.csv"))    area_list = np.arange(0, 100, 10)    temp_df = pd.DataFrame(columns=["fri", "area", "tec"])    for fri in np.unique(df["fri"]):        for a in area_list:            tec = df.loc[(df["fri"] == fri) &                         (df["area"] >= a) &                         (df["area"] < a + 10)]["tec"].mean()            temp_df = pd.concat([temp_df,                                 pd.DataFrame({"fri": [fri], "area": [a + 5], "tec": [tec]})],                                ignore_index=True)    temp_sns = temp_df.pivot(index="fri", columns="area", values="tec")    plt.figure()    sns.heatmap(temp_sns, cmap="Greens")    plt.show()def admin_eco_yc(cfg: Config) -> None:    """    Combine yield curves from multiple experiments and plot TEC per hectare across Admin-Eco regions.    Note:        The list of experiment names is currently empty.    """    exp_names = []    label_list = ["Mean MAT, PCP", "+40% MAT, -40% PCP", "+20% MAT, -20% PCP",                  "-20% MAT, +20% PCP", "-40% MAT, +40% PCP", "-40% MAT, -40% PCP",                  "-20% MAT, -20% PCP", "+20% MAT, +20% PCP", "+40% MAT, +40% PCP"]    combine_dir = os.path.join(cfg.plot_dir, "combine")    df = pd.DataFrame(columns=["Admin-Eco", "Total Ecosystem Carbon (Tonnes/Hectare)", "Exp Type"])    for i in range(len(exp_names)):        plot_dir = os.path.join(cfg.plot_dir, exp_names[i])        df_temp = pd.read_csv(os.path.join(plot_dir, "tec_admin_eco_perhc.csv"))        if "Unnamed: 0" in df_temp.columns:            df_temp = df_temp.drop(columns=["Unnamed: 0"])        df_temp["Exp Type"] = label_list[i]        df = pd.concat([df, df_temp], ignore_index=True)    plt.figure()    sns.catplot(        data=df, kind="bar",        x="Admin-Eco", y="Total Ecosystem Carbon (Tonnes/Hectare)",        hue="Exp Type", errorbar="sd", palette="dark", alpha=0.6, height=6    )    plt.savefig(os.path.join(combine_dir, "tec_admin_eco_yc_perhc.png"))    plt.close()def alter_nt_yields(cfg: Config) -> None:    """    Alter NT yield curves by processing an Excel file and saving the results as a CSV file.    Parameters:        cfg (Config): Configuration object with 'data_dir' and 'strat_map' attributes.    """    path = os.path.join(cfg.data_dir, "yield_curves", "nt_yields", "YIELD_LINK.xlsx")    nt_yields = pd.read_excel(path)    unique_stratum = nt_yields["STRATUM"].unique()    time_steps_int = np.arange(0, 101, 5)    time_steps = [str(t) for t in time_steps_int]    yield_df = pd.DataFrame(columns=["LdSpp", "density", "site_q", "AIDBSPP"] + time_steps)    for strat in unique_stratum:        subset_stratum = nt_yields.loc[nt_yields["STRATUM"] == strat].reset_index(drop=True)        strat_props = cfg.strat_map[strat]        new_row = pd.Series({            "LdSpp": strat_props["sp"],            "density": strat_props["density"],            "site_q": strat_props["sq"],            "AIDBSPP": strat_props["sp"]        })        yield_list = subset_stratum["BM_TOTAL_VOL"]        yield_list_new = []        for i in range(11):            yield_list_new.append(yield_list[i])            if i != 10:                yield_list_new.append((yield_list[i] + yield_list[i + 1]) / 2)        for y_val, t_s in zip(yield_list_new, time_steps):            new_row[t_s] = y_val        new_row = new_row.to_frame().T        yield_df = pd.concat([yield_df, new_row], ignore_index=True)    output_csv = os.path.join(cfg.data_dir, "yield_curves", "nt_yields", "nt_yields.csv")    yield_df.to_csv(output_csv, index=False)def plot_nt_yields(cfg: Config) -> None:    """    Plot NT yield curves for different species groups and save each plot as a PNG file.    Parameters:        cfg (Config): Configuration object with 'data_dir' and 'plot_dir' attributes.    """    nt_yld_dir = os.path.join(cfg.data_dir, "yield_curves", "nt_yields")    y_df = pd.read_csv(os.path.join(nt_yld_dir, "nt_yields.csv"))    sps = ["Deciduous", "Mixed Wood", "Pine", "Black Spruce", "White Spruce"]    density = ["High", "Low"]    site_q = ["Good", "Medium", "Poor"]    colors = ["r", "b", "g", "m", "c", "y"]    age = np.arange(0, 101, 5)    age_str = [str(c) for c in age]    for sp in sps:        subset_df = y_df.loc[y_df["LdSpp"] == sp]        plt.figure()        ct = 0        for d in density:            for sq in site_q:                s = subset_df.loc[(subset_df["density"] == d) & (subset_df["site_q"] == sq)]                if not s.empty:                    yields = np.array(s[age_str])[0]                    plt.plot(age, yields, c=colors[ct], label=f"Density: {d}, Site Q: {sq}")                    ct += 1        plt.legend()        plt.xlabel("Age (Years)")        plt.ylabel("Yield Volume ($m^3$/ha)")        plt.savefig(os.path.join(cfg.plot_dir, "nt_yields", f"{sp}.png"))        plt.close()def create_grid(bounds, cell_size: float, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:    """    Create a grid of polygon cells covering the given bounds.    Parameters:        bounds: Tuple of (minx, miny, maxx, maxy).        cell_size (float): Size of each cell.        gdf (GeoDataFrame): GeoDataFrame to inherit the coordinate reference system.    Returns:        GeoDataFrame: A GeoDataFrame containing the grid of polygon cells.    """    minx, miny, maxx, maxy = bounds    x_coords = np.arange(minx, maxx, cell_size)    y_coords = np.arange(miny, maxy, cell_size)    grid_cells = []    for x in x_coords:        for y in y_coords:            cell = Polygon([                (x, y),                (x + cell_size, y),                (x + cell_size, y + cell_size),                (x, y + cell_size)            ])            grid_cells.append(cell)    return gpd.GeoDataFrame(geometry=grid_cells, crs=gdf.crs)def infer_properties(new_polygon: Polygon, gdf: gpd.GeoDataFrame) -> dict:    """    Infer properties for a new polygon by averaging numeric values and using mode for categorical values    from neighboring polygons.    Parameters:        new_polygon (Polygon): The new polygon for which to infer properties.        gdf (GeoDataFrame): GeoDataFrame containing existing features with properties.    Returns:        dict: A dictionary of inferred properties or None if no neighbors are found.    """    buffer_distance = 0.1    neighbors = gdf[gdf.geometry.buffer(buffer_distance).intersects(new_polygon)]    if neighbors.empty:        return None    inferred_properties = {}    for column in gdf.columns:        if column != 'geometry':            if np.issubdtype(neighbors[column].dtype, np.number):                inferred_properties[column] = neighbors[column].mean()            else:                inferred_properties[column] = neighbors[column].mode().iloc[0]    return inferred_propertiesdef fill_gaps(gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:    """    Fill gaps in a GeoDataFrame by creating new grid cells over a predefined gap region    and inferring their properties from neighboring polygons.    Parameters:        gdf (GeoDataFrame): Original GeoDataFrame.    Returns:        GeoDataFrame: Updated GeoDataFrame with gaps filled.    """    cell_size = 0.06    gap = Polygon([(-105, 60), (-95, 60), (-95, 62), (-105, 62), (-105, 60)])    gap_grid = create_grid(gap.bounds, cell_size, gdf)    for _, cell in gap_grid.iterrows():        properties = infer_properties(cell.geometry, gdf)        if properties:            new_feature = properties.copy()            new_feature['geometry'] = cell.geometry            new_gdf = gpd.GeoDataFrame([new_feature], crs=gdf.crs)            gdf = pd.concat([gdf, new_gdf], ignore_index=True)    return gdfif __name__ == "__main__":    pass